// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"sync"

	"github.com/nadundesilva/k8s-replicator/pkg/kubernetes"
	"k8s.io/client-go/tools/cache"
)

// Ensure, that InformerMock does implement kubernetes.Informer.
// If this is not the case, regenerate this file with moq.
var _ kubernetes.Informer = &InformerMock{}

// InformerMock is a mock implementation of kubernetes.Informer.
//
//	func TestSomethingThatUsesInformer(t *testing.T) {
//
//		// make and configure a mocked kubernetes.Informer
//		mockedInformer := &InformerMock{
//			AddEventHandlerFunc: func(handler cache.ResourceEventHandler)  {
//				panic("mock out the AddEventHandler method")
//			},
//			HasSyncedFunc: func() bool {
//				panic("mock out the HasSynced method")
//			},
//		}
//
//		// use mockedInformer in code that requires kubernetes.Informer
//		// and then make assertions.
//
//	}
type InformerMock struct {
	// AddEventHandlerFunc mocks the AddEventHandler method.
	AddEventHandlerFunc func(handler cache.ResourceEventHandler)

	// HasSyncedFunc mocks the HasSynced method.
	HasSyncedFunc func() bool

	// calls tracks calls to the methods.
	calls struct {
		// AddEventHandler holds details about calls to the AddEventHandler method.
		AddEventHandler []struct {
			// Handler is the handler argument value.
			Handler cache.ResourceEventHandler
		}
		// HasSynced holds details about calls to the HasSynced method.
		HasSynced []struct {
		}
	}
	lockAddEventHandler sync.RWMutex
	lockHasSynced       sync.RWMutex
}

// AddEventHandler calls AddEventHandlerFunc.
func (mock *InformerMock) AddEventHandler(handler cache.ResourceEventHandler) {
	if mock.AddEventHandlerFunc == nil {
		panic("InformerMock.AddEventHandlerFunc: method is nil but Informer.AddEventHandler was just called")
	}
	callInfo := struct {
		Handler cache.ResourceEventHandler
	}{
		Handler: handler,
	}
	mock.lockAddEventHandler.Lock()
	mock.calls.AddEventHandler = append(mock.calls.AddEventHandler, callInfo)
	mock.lockAddEventHandler.Unlock()
	mock.AddEventHandlerFunc(handler)
}

// AddEventHandlerCalls gets all the calls that were made to AddEventHandler.
// Check the length with:
//
//	len(mockedInformer.AddEventHandlerCalls())
func (mock *InformerMock) AddEventHandlerCalls() []struct {
	Handler cache.ResourceEventHandler
} {
	var calls []struct {
		Handler cache.ResourceEventHandler
	}
	mock.lockAddEventHandler.RLock()
	calls = mock.calls.AddEventHandler
	mock.lockAddEventHandler.RUnlock()
	return calls
}

// HasSynced calls HasSyncedFunc.
func (mock *InformerMock) HasSynced() bool {
	if mock.HasSyncedFunc == nil {
		panic("InformerMock.HasSyncedFunc: method is nil but Informer.HasSynced was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHasSynced.Lock()
	mock.calls.HasSynced = append(mock.calls.HasSynced, callInfo)
	mock.lockHasSynced.Unlock()
	return mock.HasSyncedFunc()
}

// HasSyncedCalls gets all the calls that were made to HasSynced.
// Check the length with:
//
//	len(mockedInformer.HasSyncedCalls())
func (mock *InformerMock) HasSyncedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHasSynced.RLock()
	calls = mock.calls.HasSynced
	mock.lockHasSynced.RUnlock()
	return calls
}
